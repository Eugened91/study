# GRADED FUNCTION
import numpy as np


# Наша функция будет проходить через матрицу, изменяя каждую строку так, чтобы привести матрицу к эшелонированной форме.
# Если в какой-то момент она не сможет поставить 1 в главную диагональ,
# мы вернем значение True, в противном случае мы вернем False.
# Эту функцию изменять не надо.


def isSingular(A):
    B = np.array(A, dtype=np.float_)  # Делает B как копию матрицы A, так как мы будем менять ее значения.
    try:
        fixRowZero(B)
        fixRowOne(B)
        fixRowTwo(B)
        fixRowThree(B)
    except MatrixIsSingular:
        return True
    return False


# Следующая строка определяет наш флаг ошибки, когда что-то идет не так, и это значит матрица сингулярная.
# Нет необходимости редактировать эту строку.
class MatrixIsSingular(Exception): pass


# Для нулевой строки все, что нам нужно - это сделать нулевой элемент A[0,0] равным 1.
# Для этого мы разделим всю строку на значение A[0,0].
# Однако, если A[0,0] = 0, это вызовет ошибку деления на ноль, поэтому сначала мы его проверим,
# и если это так, то перед делением мы прибавим одну из нижних строк к этой нулевой строке.
# Если это не поможет, будем повторять такую проверку для каждой следущей строки до тех пор, пока деление не станет возможным.
# Если так и не найдем нужную строку, значит, матрица сингулярна
# Эта функция уже готова, не редактируйте ее.
def fixRowZero(A):
    if A[0, 0] == 0:
        A[0] = A[0] + A[1]
    if A[0, 0] == 0:
        A[0] = A[0] + A[2]
    if A[0, 0] == 0:
        A[0] = A[0] + A[3]
    if A[0, 0] == 0:
        raise MatrixIsSingular()
    A[0] = A[0] / A[0, 0]
    return A


# Сначала мы установим элементы (то есть A[1,0]) под главной диагональю в ноль.
# Далее нам надо, чтобы элемент на диагонали был равен единице, и мы разделим строку на значение A[1,1].
# Опять же, нам нужно проверять, не ноль ли A[1,1].
# Если это так, мы прибавим нижнюю строку и повторим установку поддиагональных элементов в ноль.
# Нет необходимости редактировать эту функцию.
def fixRowOne(A):
    A[1] = A[1] - A[1, 0] * A[0]
    if A[1, 1] == 0:
        A[1] = A[1] + A[2]
        A[1] = A[1] - A[1, 0] * A[0]
    if A[1, 1] == 0:
        A[1] = A[1] + A[3]
        A[1] = A[1] - A[1, 0] * A[0]
    if A[1, 1] == 0:
        raise MatrixIsSingular()
    A[1] = A[1] / A[1, 1]
    return A


# Это первая функция, которую вы напишете самостоятельно.
# Следуйте инструкциям внутри функции
def fixRowTwo(A):
    # Вставьте код, который установит поддиагональные элементы второй строки в ноль (их там два).
    A[2] = A[2] - A[2, 0] * A[0]
    A[2] = A[2] - A[2,1]*A[0]
    # Далее проверьте, что диагональный элемент не равен нулю.
    if A[2, 2] == 0:
    # Вставьте код, который складывает нижнюю строку со строкой 2.
        A[2] = A[2] + A[3]
    # Теперь повторите ваш код, который устанавливает поддиагональные элементы на ноль.
        A[2] = A[2] - A[2, 0] * A[0]
        A[2] = A[2] - A[2, 1] * A[0]
    if A[2, 2] == 0:  # и если элемент на диагонали всё равно нулевой, вызываем ошибку:
        raise MatrixIsSingular()

    # Наконец, установите диагональный элемент в единицу, разделив всю строку на этот элемент.
    A[2] = A[2] / A[2, 2]
    return A


# Эта функция, которую вы так же напишете самостоятельно
# Следуйте инструкциям внутри функции.
def fixRowThree(A):
    # Вставьте код, который установит поддиагональные элементы третьей строки в ноль.
    A[3] = A[3] - A[3, 0] * A[0]
    A[3] = A[3] - A[3, 1] * A[0]
    A[3] = A[3] - A[3, 2] * A[0]
    # Допишите оператор if, чтобы проверить, равен ли диагональный элемент нулю.
    if A[3, 3] == 0:
        raise MatrixIsSingular()
    # Преобразуйте строку, чтобы установить диагональный элемент в единицу.
    A[3] = A[3] / A[3,3]
    return A
